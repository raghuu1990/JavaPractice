XOR(^) is a binary operation called exclusive OR and works as
A ^ B == (A & B) ^ (A | B)

1^0 = 1  
0^1 = 1  
0^0 = 0
1^1 = 0  

XOR by 1 can work like a toggle switch that turns 1 to 0 or 0 to 1.

Another interesting thing to note is

x^0 = x 
x^x = 0


Swap 2 nos :

A = A^B
B = A^B
A = A^B

XOR(1-n)
i=0 0 
i=1 1 
i=2 3
i=3 0 
i=4 4
i=5 1 
i=6 7 
i=7 0
i=8 8 
i=9 1 
i=10 11 
i=11 0 
i=12 12 
i=13 1 
i=14 15 
i=15 0 
i=16 16 
i=17 1 

Number Binary-Repr  XOR-from-1-to-n
1         1           [0001]  <----- We get a 1
2        10           [0011]  <----- We get a n+1
3        11           [0000]  <----- We get a 0
4       100           [0100]  <----- Equals to n
5       101           [0001]
6       110           [0111]
7       111           [0000]  <----- We get 0
8      1000           [1000]  <----- Equals to n
9      1001           [0001]
10     1010           [1011]
11     1011           [0000] <------ We get 0
12     1100           [1100] <------ Equals to n

	  XOR(1 to n)	 XOR(XOR(n-1),n)
i=0  -->  0 (n)	  --> 0*  (n)    					(Exception default 0)
i=1  -->  1 (1)	  --> 1   (1)
i=2  -->  3 (n+1) --> 3   (n+1)
i=3  -->  0 (0)	  --> 0	  (0)     0^1^3^0   = 2
i=4  -->  4 (n)	  --> 4	  (n)
i=5  -->  1 (1)	  --> 1   (1)	
i=6  -->  7 (n+1) --> 7	  (n+1)
i=7  -->  0 (0)   --> 0	  (0)	  4^1^7^0   = 2
i=8  -->  8 (n)	  --> 8	  (n)
i=9  -->  1 (1)	  --> 1   (1)  
i=10 --> 11 (n+1) --> 11  (n+1)
i=11 --> 0  (0)	  --> 0	  (0)	  8^1^11^0  = 2
i=12 --> 12 (n)	  --> 12  (n)
i=13 --> 1  (1)	  --> 1	  (1)
i=14 --> 15 (n+1) --> 15  (n+1)
i=15 --> 0  (0)	  --> 0	  (0)	  12^1^15^0 = 2
i=16 --> 16 (n)	  --> 16  (n)
i=17 --> 1  (1)	  --> 1	  (1)
i=18 --> 19 (n+1) --> 19  (n+1)
i=19 --> 0 	(0)	  --> 0	  (0)	  16^1^19^0 = 2

int computeXOR(int n)
{
    // If n is a multiple of 4
    if (n % 4 == 0)
        return n;
 
    // If n%4 gives remainder 1
    if (n % 4 == 1)
        return 1;
 
    // If n%4 gives remainder 2
    if (n % 4 == 2)
        return n + 1;
 
    // If n%4 gives remainder 3
    return 0;
}